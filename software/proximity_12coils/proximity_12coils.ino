// cristinel.ababei, jim.richie, copyleft :-), october 2020
//
// this is a collaboration project between cristinel ababei and jim richie
// at marquette, electrical and computer engr. department
// 
// code here is used in the first generation of a proximity sensor design formed by:
// 1--base board = Atmega328p + LDC inductance to digital converter
//    this is called also Proximity Board in the comments of the code here;
// 2--two separate sensor boards, one LC tanks, two LC tanks
//    each of the sensor boards is a plug-and-play board; the one with one LC tank
//    can be used for detecting metal targets approaching perpendicularly to
//    the sensor board plane' the sensor board with two LC tanks can be used for
//    detecting metal targets moving laterally;
// 
// the LDC inductance to digital converter has two operation modes, which
// you can select in the code below by selecting one of the following when
// the "my_ldc" variable is declared:
// 1-- LDC_LHR_OPERATION (high-resolution, 24 it, inductance measurement) <--- default 
// 2-- LDC_RP_PLUS_L_OPERATION (equivalent parallel resistance RP and inductance, 16 bit, measurement)
//
// Notes:
// 
// Please see the additional documentation and files of this project for details:
// Our papers and the report for this project, the source code on github and 
// PCB layout files. See the LDC1101 datasheet NOW to be in a good position to
// read this code!
//
// ProximityBoard is programmed in the easiest way from Arduino IDE - just like 
// an Arduino Pro Mini board (3.3V) because this is how I designed it. 
// But, not all the pins are with the same meaning/definition
// as for an actual Pro Mini. To understand that you need to look at the schematic
// diagram of the ProximityBoard and at the pin-out diagram of the ProMini.
// The other way you can code and program the ProximityBoard is by using directly avrdude.
//
// In the ProximityBoard design I made the mistake to use the SS pin of 
// the SPI peripheral as battery low pin to drive an LED; and, instead
// I used PB1 as a pin with the function of slave select to use to 
// connect to the LDC; I should have used these two pins swapped! will do next time;
// for now, I need to replacce the IDE pin SS with PB1 (IDE pin 9) so that the LDC
// will be selected correctly as a Slave chip, by the MCU Atmega328p the master;
//
// That is why I duplicated the SPIClass which is the type-of that the SPI object
// defined by Arduino IDE; so, inside that class the standard SS (IDE pin 10) should
// be substituted with IDE pin 9, which I have used in the ProximityBoard;
// I created a new class SPIClass2 inside SPI2.h and SPI2.cpp to get around that;
// So much pain for the swapping two pins... mistakes cost. :-)
//
// the other Arduino Pro Mini's pins that are used as SPI pins are the standard ones
// (see Arduini Pro Mini pinout diagram): 
// MOSI    IDE pin 11: is MCU pin 15
// MISO    IDE pin 12: is MCU pin 16
// SCK     IDE pin 13: is MCU pin 17

#include <Wire.h> 
#include "ldc1101.h"


#define DEBUG false


// Thresholds used to mark that metal target approached the sensor;
#define THRESHOLD_PERCENTAGE_CHANGE_LHR_DATA 3.0
#define THRESHOLD_PERCENTAGE_CHANGE_fSENSOR  3.0


// DS1077L - Dallas Semiconductor Maxim clock generator
//
// I use it to generate a clock of 10 MHz for the LDC1101;
// It needs to be configured via I2C by the MCU Atmega328;
// DS1077L can generate an oscillator frequency in the range 4.87kHz to 66.666MHz
// https://www.sparkfun.com/products/retired/9116

#define DS1077L_ADDRESS 0x58 // DS1077L default address 0x58


// LDC1101 - TI's inductance to digital converter
//
// MCU Atmega328p is connected to the inductance to digital converter LDC1101;
// they talk via SPI;
// create LDC1101 object to talk to the inductance-to-digital converter chip via SPI2;
// ss_pin is IDE pin 9; 
// capacitor = 270pF
// f_CLKIN = 10MHz: frequency of external clock generated by clock-gen
// _operation_mode is: LDC_LHR_OPERATION (default!) or LDC_RP_PLUS_L_OPERATION

LDC1101 my_ldc(9, 270E-12, 10000000.0, LDC_LHR_OPERATION); 


char str_temp[64];
char temp[64];
// visual of how boards are attached:
// ----------     ----------
//           | --|
//           | --| LC2 tank(default)
// Base Board| --|                  Sensor Board
//           | --| LC1 tank 
// ----------     ----------
// by default single LC2 tank sensor board are connected what on the schematic diagram
// of the base board is LC2 port (upper port); so, by default we would work with just
// one LC tank connected to port #2; that is why I use these variables ID-ed with 2:
uint32_t prev_LHR_data2 = 0;
uint32_t curr_LHR_data2 = 0;
double change_in_LHR_data2 = 0.0; 
double prev_fsensor2 = 0.0;
double curr_fsensor2 = 0.0;
double percent_change_in_fSENSOR2 = 0.0;
double delta_fSENSOR2 = 0.0;
// variables for working with LC1 tank, when it exists
uint32_t prev_LHR_data1 = 0;
uint32_t curr_LHR_data1 = 0;
double change_in_LHR_data1 = 0.0; 
double prev_fsensor1 = 0.0;
double curr_fsensor1 = 0.0;
double percent_change_in_fSENSOR1 = 0.0;
double delta_fSENSOR1 = 0.0;
// keep track of whether target was detected from RIGHT or from LEFT
boolean target_detected_right = false; // by LC2 tank
boolean target_detected_left = false;  // by LC1 tank

// sketch variables;
uint32_t curr_LHR_data_to_ignore = 0;
boolean have_driven_LC2 = false; 
int my_counter = 0;

// in this implementation the proximity sensor can have:
// either one LC2 tank with L covering the whole plane of the sensor; 
// or, two tanks, LC1 & LC2 which are used to detect direction of metal target;
boolean exists_LC1 = false;
boolean exists_LC2 = false;


///////////////////////////////////////////////////////////////////////////////
//
// setup
//
///////////////////////////////////////////////////////////////////////////////

void setup() 
{
  // () after the ProximityBoard (programmed as an Arduino Pro Mini) is programmed, 
  // we use Arduino's serial terminal as a debugging interface, to print stuff, etc.;
  Serial.begin(9600);
  Serial.print("********************************************************* \r\n"); 
  Serial.print("Started Serial... \r\n");
  
  
  // () start the I2C library; used to talk to the DS1077L clock generator;
  Serial.print("********************************************************* \r\n");
  Serial.print("Configure clock-generator: DS1077L: \r\n");
  Wire.begin();
  //read_print_DS1077L_registers();
  init_DS1077L_clock_generator(); 
  read_print_DS1077L_registers(); 

  
  // () check vitals of the sensor LDC1101 inductance to digital converter;
  Serial.print("********************************************************* \r\n");
  Serial.print("Check status of inductance to digital converter: LDC1101... \r\n");
  query_LDC1101_device_during_setup( DEBUG);

  // the MCU pin 2 (or PD4), which is IDE pin 4 drives the RED LED to
  // signal that metal target entered the sensor's vicinity;
  // so, set this pin as out here; 
  pinMode(4, OUTPUT);
  digitalWrite(4, LOW);
  
  
  // () configure the MUX to connect tank LC2 to the inductance-to-digital converter;
  // the MUX is the "TS5A23157 Dual 10-Ω SPDT Analog Switch" IC, which
  // I control with PB0 (IDE pin 8, also MCU pin 12); 
  // to control the MUX to select LC2 (i.e., LC2_INA and LC2_INB) I need to set the control pin HIGH;
  Serial.print("********************************************************* \r\n");
  Serial.print("Configure MUX: TS5A23157 Dual 10-Ω SPDT Analog Switch... \r\n");
  pinMode(8, OUTPUT);
  
  // identify if we have a board sensor with just one LC tank (LC2)
  // or two LC tanks (for direction detection);
  scan_LC_tank_ports(); // will drive IDE pin 8 high and low
  get_one_time_current_frequency(); // read from LDC and set "curr" frequency(ies)
  digitalWrite(8, HIGH); // place the MUX on default connecting to LC2 tank that always should exist 
  
  
  // () Low Battery LED (should have been SS pin for the SPI bus!);
  // we blink it for debug purposes;
  pinMode(10, OUTPUT);
  digitalWrite(10, HIGH);
  
  
  // () done setup;
  Serial.print("\r\nDone setup \r\n");
  Serial.print("********************************************************* \r\n");
}


///////////////////////////////////////////////////////////////////////////////
//
// main loop
//
///////////////////////////////////////////////////////////////////////////////

void loop() 
{
  
  // print debug info;
  //my_counter++; Serial.print(my_counter); Serial.print("\r\n");
  print_debug_information_during_loop( DEBUG);
  


  // () PART 1: LDC_LHR_OPERATION (default!)
  // get raw measured data for inductance;
  // then, compute fSENSOR and LSENSOR;
  // look at the sign or direction of change of fSENSOR; when freq increases
  // turn the red LED on; that is target is approaching; let user know;
  // if direction sensing turn red LED on and signal in serial terminal; 
  if ( my_ldc.get_operation_mode() == LDC_LHR_OPERATION ) { // default    
    // ------------------------- CASE #1 -------------------------
    if ( exists_LC2 == true && exists_LC1 == false) { 
      check_metal_target_approaching_perpendicularly();
    } 
    // ------------------------- CASE #2 -------------------------
    if ( exists_LC2 == true && exists_LC1 == true) { 
      check_metal_target_moving_from_RIGHT();
      check_metal_target_moving_from_LEFT();
      // reset;
      if ( target_detected_right == true || target_detected_left == true) { 
        target_detected_right = false;
        target_detected_left = false;
        get_one_time_current_frequency();   
      }
    } 
  } 
  
  // PART 2:
  // Note 1: to get into this branch of this "if" statement, you must use the
  // approapriate argument when the "my_ldc" variable is declared at the top of this file!
  // Note 2: here I only read and print in the terminal the values provided by the LDC converter;
  // I am NOT using those for anything; feel free to build your own logic here as
  // I did in Part 1 above, which is my default mode of operation;
  else { // LDC_RP_PLUS_L_OPERATION
    print_debug_information_during_loop( true);
  } 

}


///////////////////////////////////////////////////////////////////////////////
//
// I2C functions
// DS1077L - clock generator (frequency synthesizer)
//
///////////////////////////////////////////////////////////////////////////////

void i2c_write(int device, byte address) 
{
  Wire.beginTransmission(device); //start transmission to device 
  Wire.write(address);        // send register address
  Wire.endTransmission(); //end transmission
}

void i2c_write(int device, byte address, byte val1) 
{
  Wire.beginTransmission(device); //start transmission to device 
  Wire.write(address);        // send register address
  Wire.write(val1);        // send value to write
  Wire.endTransmission(); //end transmission
}

void i2c_write(int device, byte address, byte val1, byte val2) 
{
  Wire.beginTransmission(device); //start transmission to device 
  Wire.write(address);        // send register address
  Wire.write(val1);        // send value to write
  Wire.write(val2);        // send value to write
  Wire.endTransmission(); //end transmission
}

void init_DS1077L_clock_generator() 
{
  // initialize DS1077L
  // The master oscillator used in the DS1077L is a CMOS oscillator with compensation circuitry;
  // Four standard master frequency options are available: 40MHz, 50MHz, 60MHz, and 66.66MHz;
  // I goot from Digikey the one with reference frequency 40MHz (should have gotten the 60MHz);
  // We want the 40MHz, which we devide by 4 to get a 10MHz to the OUT1 of the clock-gen, which we feed
  // into LDC1101;
  
  // (1) set CTRL0 and CTRL1 of the clock generator to 0; reccommended;
  // these are connected to PD2 and PD3 of the Atmega328p MCU in teh ProximityBoard;
  // that is Arduino IDE pins 2 and 3;
  pinMode(2, OUTPUT);
  digitalWrite(2, LOW);
  pinMode(3, OUTPUT);
  digitalWrite(3, LOW);

  // (2) See Datasheet for the info below!
  // MUX WORD:   first data byte                      second data byte
  // Name:       * PDN1 PDN0 SEL0 EN0 0M1 0M0 1M1     1M0 DIV1 - - - - - -
  // Default:    0 0    0    1    1   0   0   0       0   0    x x x x x x
  // My settings:0 0    0    0    0   0   0   0       0   0    0 0 0 0 0 0 <--- 0x00, 0x00
  //
  // DIV WORD:
  // MSB                  LSB   MSB             LSB
  // N9 N8 N7 N6 N5 N4 N3 N2    N1 N0 X X X X X X
  // first data byte            second data byte
  // N9:0: These ten bits determine the value of the programmable divider (N). 
  // The range of divisor values is from 2 to 1025, and is equal to the programmed value of N plus 2.
  // So, knowing that the master frequency is 40MHz, to get out a 10MHz, I would need to:
  // -- keep above 1M to 00 (so that the PRESCALER P1 DIVISOR “M” is 1 - see Table 4 in Datasheet)
  // -- set N here with my settings:
  // 0  0  0  0  0  0  0  0     1  0  0 0 0 0 0 0 <--- 0x00, 0x80
  // which means a divisor value of 2 + 2 = 4 because that would give me 40MHz/4 = 10MHz
  
  i2c_write(DS1077L_ADDRESS, 0x02, 0x00, 0x00); // write MUX
  i2c_write(DS1077L_ADDRESS, 0x01, 0x00, 0x80); // write DIV
  i2c_write(DS1077L_ADDRESS, 0x0D, 0x08); // WC = 1, the EEPROM is only written when the WRITE command is issued (Datasheet page 7)
  i2c_write(DS1077L_ADDRESS, 0x3F); // write E2
  delay(500); 
}

void read_print_DS1077L_registers() 
{
  uint16_t sketch_reg=0;
  
  Wire.beginTransmission(DS1077L_ADDRESS); // Start communication with DS1077L
  Wire.write(0x02);                        // Start reading at register 02 == MUX
  Wire.endTransmission();                  // End the transmission
  Wire.requestFrom(DS1077L_ADDRESS, 2);    // Request 2 bytes from the DS1077L
  sketch_reg = Wire.read()<<8|Wire.read(); 
  Serial.print("MUX: "); Serial.print(sketch_reg, HEX); Serial.print(" \r\n");
  
  sketch_reg=0;
  Wire.beginTransmission(DS1077L_ADDRESS); 
  Wire.write(0x01);                        // Start reading at register 01 == DIV
  Wire.endTransmission();                  
  Wire.requestFrom(DS1077L_ADDRESS, 2);    
  sketch_reg = Wire.read()<<8|Wire.read(); 
  Serial.print("DIV: "); Serial.print(sketch_reg, HEX); Serial.print(" \r\n");   
}


///////////////////////////////////////////////////////////////////////////////
//
// Functions for working with the LDC sensor
// RP+L or LHR mode
//
///////////////////////////////////////////////////////////////////////////////

void query_LDC1101_device_during_setup( boolean debug)
{
  // debugging purposes only; used during setup;
  
  uint32_t LHR_data = 0;
  uint16_t L_data = 0;
  uint16_t RESP_TIME = 0;
  uint16_t RCOUNT = 13;

  if ( my_ldc.get_operation_mode() == LDC_LHR_OPERATION ) { // default
    Serial.print("Inductance-to-digital converter mode of operation: LHR\r\n");
  } else { // LDC_RP_PLUS_L_OPERATION
    Serial.print("Inductance-to-digital converter mode of operation: RP+L\r\n");
  }
  
  if ( debug == true) {   
    // RCOUNT
    RCOUNT = my_ldc.get_Rcount(); // <--- does a readSPI
    Serial.print("RCOUNT = "); Serial.print(RCOUNT); Serial.print("\r\n");

    // RESP_TIME: 384 (default value) corresponts to "#" stored in DIG_CONF register
    RESP_TIME = my_ldc.get_responsetime(); // <--- does a readSPI
    Serial.print("RESP_TIME = "); Serial.print(RESP_TIME); Serial.print("\r\n");
    
    // f_CLKIN: frequency of external clock: 10MHz in my case
    dtostrf(my_ldc.get_fCLKIN(), 16, 2, str_temp); 
    sprintf(temp, "fCLKIN = %s Hz", str_temp); 
    Serial.print(temp); Serial.print("\r\n");

    // Parallel capacitance 
    dtostrf(my_ldc.get_cap(), 24, 16, str_temp); 
    sprintf(temp, "capacitance = %s F", str_temp); 
    Serial.print(temp); Serial.print("\r\n");
     
    //LHR_data = my_ldc.get_LHR_Data(); // LHR mode <--- does a readSPI
    //Serial.print("LHR_data = "); Serial.print(LHR_data); Serial.print("\r\n");
    //L_data = my_ldc.get_L_Data(); // RP+L mode <--- does a readSPI
    //Serial.print("L_data = "); Serial.print(L_data); Serial.print("\r\n");

    // f_sensor: the calculated frequency of the sensor 
    //dtostrf(my_ldc.get_fsensor( LHR_data ), 24, 16, str_temp); 
    //dtostrf(my_ldc.get_fsensor( L_data ), 24, 16, str_temp);
    //sprintf(temp, "fsensor, frequency = %s Hz", str_temp); 
    //Serial.print(temp); Serial.print("\r\n");
    
    // _inductance = 1./(_cap * 4*PI*PI*fsensor*fsensor); 
    //dtostrf(my_ldc.get_Inductance( LHR_data ), 24, 16, str_temp); 
    //dtostrf(my_ldc.get_Inductance( L_data ), 24, 16, str_temp); 
    //sprintf(temp, "L_SENSOR, inductance = %s H", str_temp); 
    //Serial.print(temp); Serial.print("\r\n");
  }  
} 

void print_debug_information_during_loop( boolean debug)
{
  // debugging purposes only; used during loop;

  uint8_t LHR_status = 0;
  uint32_t LHR_data = 0;
  uint8_t RPL_status = 0;
  uint16_t RP_data = 0;
  uint16_t L_data = 0;

  // poll the sensor data; the sensor, LDC1101 must be in LDC_MODE_ACTIVE_CONV
  if ( debug == true) {
    //Serial.print("\r\nMeasurement mode... \r\n");

    if ( my_ldc.get_operation_mode() == LDC_LHR_OPERATION ) { // default
    
      if ( my_ldc.is_New_LHR_data() == true) { 
          // If: '0' : Unread LHR conversion data is available.
          // If: '1' : No unread LHR conversion data is available.
          LHR_status = my_ldc.get_LHR_status(); // <--- does a readSPI
          Serial.print("LHR_status = "); Serial.print(LHR_status); Serial.print("\r\n");
          
          // raw measured data for inductance
          LHR_data = my_ldc.get_LHR_Data(); // LHR mode <--- does a readSPI
          Serial.print("LHR_data = "); Serial.print(LHR_data); Serial.print("\r\n");
          
          // f_sensor: the calculated frequency of the sensor 
          // _fsensor = two_to_divider * _fCLKIN * (Ldata + _LHRoffset*256)/16777216; // Hz
          dtostrf(my_ldc.get_fsensor( LHR_data ), 24, 16, str_temp); 
          sprintf(temp, "Frequency fSENSOR  = %s Hz", str_temp); 
          Serial.print(temp); Serial.print("\r\n");
          
          // _inductance = 1./(_cap * 4*PI*PI*fsensor*fsensor); 
          dtostrf(my_ldc.get_Inductance( LHR_data ), 24, 16, str_temp); 
          sprintf(temp, "Inductance L_SENSOR = %s H", str_temp); 
          Serial.print(temp); Serial.print("\r\n");
      } else {
        Serial.print("No unread LHR conversion data is available.\r\n");
      }
      
    } else { // LDC_RP_PLUS_L_OPERATION
    
      if ( my_ldc.is_RP_L_DataReady() == true) { 
        RPL_status = my_ldc.get_status(); // <--- does a readSPI
        Serial.print("status = "); Serial.print(RPL_status); Serial.print("\r\n");

        // raw measured data for inductance
        L_data = my_ldc.get_L_Data(); // RP+L mode <--- does a readSPI
        Serial.print("L_data = "); Serial.print(L_data); Serial.print("\r\n");
        
        // f_sensor: the calculated frequency of the sensor 
        // _fsensor = (_fCLKIN * 6144) / (3 * Ldata);
        dtostrf(my_ldc.get_fsensor( L_data ), 24, 16, str_temp);
        sprintf(temp, "Frequency fSENSOR  = %s Hz", str_temp);  
        Serial.print(temp); Serial.print("\r\n");
        
        // _inductance = 1./(_cap * 4*PI*PI*fsensor*fsensor); 
        dtostrf(my_ldc.get_Inductance( L_data ), 24, 16, str_temp); 
        sprintf(temp, "Inductance L_SENSOR = %s H", str_temp); 
        Serial.print(temp); Serial.print("\r\n");
         
        RP_data = my_ldc.get_RP_Data();
        Serial.print("RP_data = "); Serial.print(RP_data); Serial.print("\r\n");
        
        dtostrf(my_ldc.get_RP( RP_data ), 24, 16, str_temp);
        sprintf(temp, "RP = %s Ohm", str_temp); 
        Serial.print(temp); Serial.print("\r\n");
      } else {
        Serial.print("No new RP+L conversion data is available.\r\n");
      }  
      
    }
  }
} 

void scan_LC_tank_ports(void) 
{
  // NOTE: to be used only in the setup portion because it used delay function;
  
  // scan to detect if a sensor with one coil or a sensor with two
  // coils is attached to the base-board;
  // the base board on left, sensor board on right:
  // ----------     ----------
  //           | --|
  //           | --| LC2 tank(default)
  // Base Board| --|                  Sensor Board
  //           | --| LC1 tank 
  // ----------     ----------
  
  // (1) configure the MUX to connect tank LC2 to the inductance-to-digital converter;
  // the MUX is the "TS5A23157 Dual 10-Ω SPDT Analog Switch" IC, which
  // I control with PB0 (IDE pin 8, also MCU pin 12); 
  // to control the MUX to select LC2 (i.e., LC2_INA and LC2_INB) I need to set the control pin HIGH;
  digitalWrite(8, HIGH); 
  // ----------     ----------
  //           | --|
  //           | --| LC2 tank(default)
  // Base Board|   |                  Sensor Board
  //           |   | LC1 tank 
  // ----------     ----------
  // then, try a few times to read LHR data; if there is an LC2 tank attached, then, it will
  // be detected;
  for (int i = 0; i < 4; i++) {
    if ( my_ldc.get_operation_mode() == LDC_LHR_OPERATION ) { // default   
      if ( my_ldc.is_New_LHR_data() == true) { 
        curr_LHR_data2 = my_ldc.get_LHR_Data();
        curr_fsensor2 = my_ldc.get_fsensor( curr_LHR_data2 );
        // if curr_fsensor2 is ridiculously large (empirically found)
        // then, there is no LC2 tank!
        if (curr_fsensor2 < 1E9) exists_LC2 = true;
        else exists_LC2 = false;
      } else {
        exists_LC2 = false;
      }
    } else { // LDC_RP_PLUS_L_OPERATION  
      if ( my_ldc.is_RP_L_DataReady() == true) { 
        curr_LHR_data2 = my_ldc.get_LHR_Data();
        curr_fsensor2 = my_ldc.get_fsensor( curr_LHR_data2 );
        // if curr_fsensor2 is ridiculously large (empirically found)
        // then, there is no LC2 tank!
        if (curr_fsensor2 < 1E9) exists_LC2 = true;
        else exists_LC2 = false;
      } else {
        exists_LC2 = false;
      }  
    }
    delay(100);     
  }
  
  // (2) configure the MUX to connect tank LC1 to the inductance-to-digital converter;
  digitalWrite(8, LOW); 
  // ----------     ----------
  //           |   |
  //           |   | LC2 tank(default)
  // Base Board| --|                  Sensor Board
  //           | --| LC1 tank 
  // ----------     ----------
  // then, try a few times to read LHR data; if there is an LC1 tank attached, then, it will
  // be detected;
  for (int i = 0; i < 4; i++) {
    if ( my_ldc.get_operation_mode() == LDC_LHR_OPERATION ) { // default   
      if ( my_ldc.is_New_LHR_data() == true) { 
        curr_LHR_data1 = my_ldc.get_LHR_Data();
        curr_fsensor1 = my_ldc.get_fsensor( curr_LHR_data1 );
        // if curr_fsensor1 is ridiculously large (empirically found)
        // then, there is no LC1 tank!
        if (curr_fsensor1 < 1E9) exists_LC1 = true;
        else exists_LC1 = false;
      } else {
        exists_LC1 = false;
      }
    } else { // LDC_RP_PLUS_L_OPERATION  
      if ( my_ldc.is_RP_L_DataReady() == true) { 
        curr_LHR_data1 = my_ldc.get_LHR_Data();
        curr_fsensor1 = my_ldc.get_fsensor( curr_LHR_data1 );
        // if curr_fsensor1 is ridiculously large (empirically found)
        // then, there is no LC1 tank!
        if (curr_fsensor1 < 1E9) exists_LC1 = true;
        else exists_LC1 = false;
      } else {
        exists_LC1 = false;
      }  
    }
    delay(100);     
  }
  
  if (exists_LC2 == true) Serial.print("\r\nLC2 tank: YES \r\n");
  else Serial.print("\r\nLC2 tank: NO \r\n");
  
  if (exists_LC1 == true) Serial.print("\r\nLC1 tank: YES \r\n");
  else Serial.print("\r\nLC1 tank: NO \r\n");
}


void get_one_time_current_frequency(void) 
{
  // read and record current frequency
  // in this way during the loop, we'll have already a value to assign to as 
  // the previous value for frequency;
  
  // PART 1:
  if ( my_ldc.get_operation_mode() == LDC_LHR_OPERATION ) { // default
    
    if ( exists_LC2 == true && exists_LC1 == false) { // default; sensor board with one coil
      while ( my_ldc.is_New_LHR_data() == false) {};  
      curr_LHR_data_to_ignore = my_ldc.get_LHR_Data();
      while ( my_ldc.is_New_LHR_data() == false) {};  
      curr_LHR_data2 = my_ldc.get_LHR_Data();
      curr_fsensor2 = my_ldc.get_fsensor( curr_LHR_data2 ); 
    } 

    if ( exists_LC2 == true && exists_LC1 == true) { // sensor board with 2 coils
      digitalWrite(8, HIGH); // MUX to select LC2
      while ( my_ldc.is_New_LHR_data() == false) {};  
      curr_LHR_data_to_ignore = my_ldc.get_LHR_Data();
      while ( my_ldc.is_New_LHR_data() == false) {};  
      curr_LHR_data2 = my_ldc.get_LHR_Data();
      curr_fsensor2 = my_ldc.get_fsensor( curr_LHR_data2 );
      
      digitalWrite(8, LOW); // MUX to select LC1
      while ( my_ldc.is_New_LHR_data() == false) {};  
      curr_LHR_data_to_ignore = my_ldc.get_LHR_Data();
      while ( my_ldc.is_New_LHR_data() == false) {};  
      curr_LHR_data1 = my_ldc.get_LHR_Data();
      curr_fsensor1 = my_ldc.get_fsensor( curr_LHR_data1 );    
    } 
  } 
  
  // PART 2:
  else { // LDC_RP_PLUS_L_OPERATION
  
    // TODO
  }  
}


void check_metal_target_approaching_perpendicularly(void) 
{
  // this is used when a board sensor with only one LC tank, i.e., LC2
  // is connected to the base board;
  // used just for metal target detection approaching perpendicularly    

  // (1) MUX to select LC2 (i.e., LC2_INA and LC2_INB) I need to set the control pin HIGH;
  digitalWrite(8, HIGH);
  
  
  // (2) read from the converter;
  while ( my_ldc.is_New_LHR_data() == false) {};  
  prev_LHR_data2 = curr_LHR_data2;
  curr_LHR_data2 = my_ldc.get_LHR_Data();
  
  //Serial.print("prev_LHR_data2 = "); Serial.print(prev_LHR_data2); Serial.print("\r\n");
  //Serial.print("curr_LHR_data2 = "); Serial.print(curr_LHR_data2); Serial.print("\r\n");      
  //change_in_LHR_data2 = 100 * (curr_LHR_data2 - prev_LHR_data2) / curr_LHR_data;
  //dtostrf(change_in_LHR_data2, 24, 16, str_temp);
  //sprintf(temp, "Percentage change in LHR = %s", str_temp);  
  //Serial.print(temp); Serial.print("\r\n");  
        
  prev_fsensor2 = curr_fsensor2;
  curr_fsensor2 = my_ldc.get_fsensor( curr_LHR_data2 ); 
  delta_fSENSOR2 = curr_fsensor2 - prev_fsensor2; // when target metal approaches frequency increases
  //percent_change_in_fSENSOR2 = 100 * abs(curr_fsensor2 - prev_fsensor2) / prev_fsensor2;  

  // --one way to print
  //dtostrf(curr_fsensor2, 24, 16, str_temp); 
  //sprintf(temp, "fSENSOR2 = %s Hz    ", str_temp); 
  //Serial.print(temp); 
  //Serial.print("\r\n");
  //dtostrf(delta_fSENSOR2, 24, 16, str_temp); 
  //sprintf(temp, "DELTA fSENSOR2 = %s Hz", str_temp); 
  //Serial.print(temp); Serial.print("\r\n");      
  // --another way to print; but, it prints "ovf" for large values!
  //Serial.print("fSENSOR2 = "); Serial.print(curr_fsensor2); 
  //Serial.print("    Delta2 = "); Serial.print(delta_fSENSOR2); 
  //Serial.print("    Percentage2 = "); Serial.print(percent_change_in_fSENSOR2); 
  //Serial.print("\r\n");
  
  // when metal target approaches, frequency increases;
  // 2000 value was determined empirically via observations;
  if ( (delta_fSENSOR2 > 2000) ) {
    //&& (percent_change_in_fSENSOR2 > THRESHOLD_PERCENTAGE_CHANGE_fSENSOR) ) { 
    // signal target approached by turning Red the LED;
    digitalWrite(4, HIGH);
    Serial.print("-------- Metal target in proximity! --------\r\n");
  } else {
    digitalWrite(4, LOW);
  }

}


void check_metal_target_moving_from_RIGHT(void)
{
  // this is used when a board sensor with two LC tanks, i.e., LC2 & LC1
  // is connected to the base board;
  // used for metal target moving direction detection and proximity detection
  // in this case, we need to implement a logic to detect direction:
  // LC2 then LC1 == RIGHT TO LEFT
  // LC1 then LC2 == LEFT TO RIGHT
 
  
  // (1) control the MUX to select LC2 (i.e., LC2_INA and LC2_INB) I need to set the control pin HIGH;
  digitalWrite(8, HIGH); 

  
  // (2) read from the converter;
  while ( my_ldc.is_New_LHR_data() == false) {};  
  curr_LHR_data_to_ignore = my_ldc.get_LHR_Data(); 


  // if this happens before LC1 tank senses the same, it would 
  // mean a right-to-left moving detection!
  while ( my_ldc.is_New_LHR_data() == false) {}; 
  prev_LHR_data2 = curr_LHR_data2;
  curr_LHR_data2 = my_ldc.get_LHR_Data(); 
  prev_fsensor2 = curr_fsensor2;
  curr_fsensor2 = my_ldc.get_fsensor( curr_LHR_data2 ); 
  
  delta_fSENSOR2 = curr_fsensor2 - prev_fsensor2; // when target metal approaches frequency increases
  //percent_change_in_fSENSOR2 = 100 * abs(curr_fsensor2 - prev_fsensor2) / prev_fsensor2;  
  
  // one way to print
  //dtostrf(curr_fsensor2, 24, 16, str_temp); 
  //sprintf(temp, "fSENSOR2 = %s Hz    ", str_temp); 
  //Serial.print(temp); //Serial.print("\r\n");
  //dtostrf(delta_fSENSOR2, 24, 16, str_temp); 
  //sprintf(temp, "DELTA fSENSOR2 = %s Hz", str_temp); 
  //Serial.print(temp); Serial.print("\r\n");      
  // another way to print; but, it prints "ovf" for large values!
  //Serial.print("fSENSOR2 = "); Serial.print(curr_fsensor2); 
  //Serial.print("    Delta2 = "); Serial.print(delta_fSENSOR2); 
  //Serial.print("    Percentage2 = "); Serial.print(percent_change_in_fSENSOR2); 
  //Serial.print("\r\n");

  // when metal target approaches, frequency increases;
  // 2000 value was determined empirically via observations;
  if ( (delta_fSENSOR2 > 2000) ) {
    //&& (percent_change_in_fSENSOR2 > THRESHOLD_PERCENTAGE_CHANGE_fSENSOR) ) { 
    target_detected_right = true;
    // signal target approached by turning Red the LED;
    digitalWrite(4, HIGH);
    Serial.print("-------- Metal target: RIGHT! \r\n");
  } else {
    digitalWrite(4, LOW);
  }
}


void check_metal_target_moving_from_LEFT(void)
{
  // this is used when a board sensor with two LC tanks, i.e., LC2 & LC1
  // is connected to the base board; 
  // used for metal target moving direction detection and proximity detection
  // in this case, we need to implement a logic to detect direction:
  // LC2 then LC1 == RIGHT TO LEFT
  // LC1 then LC2 == LEFT TO RIGHT
 

  // (1) control the MUX to select LC1 (i.e., LC1_INA and LC1_INB) I need to set the control pin LOW;
  digitalWrite(8, LOW); 
 
  
  // (2) read from the converter;
  while ( my_ldc.is_New_LHR_data() == false) {};  
  curr_LHR_data_to_ignore = my_ldc.get_LHR_Data(); 
  
  
  // if this happens before LC2 tank senses the same, it would 
  // mean a left-to-right moving detection!
  while ( my_ldc.is_New_LHR_data() == false) {};
  prev_LHR_data1 = curr_LHR_data1;
  curr_LHR_data1 = my_ldc.get_LHR_Data(); 
  prev_fsensor1 = curr_fsensor1;
  curr_fsensor1 = my_ldc.get_fsensor( curr_LHR_data1 );
  
  delta_fSENSOR1 = curr_fsensor1 - prev_fsensor1; // when target metal approaches frequency increases
  //percent_change_in_fSENSOR1 = 100 * abs(curr_fsensor1 - prev_fsensor1) / prev_fsensor1;  
  
  // one way to print
  //dtostrf(curr_fsensor1, 24, 16, str_temp); 
  //sprintf(temp, "fSENSOR1 = %s Hz    ", str_temp); 
  //Serial.print(temp); //Serial.print("\r\n");
  //dtostrf(delta_fSENSOR1, 24, 16, str_temp); 
  //sprintf(temp, "DELTA fSENSOR1 = %s Hz", str_temp); 
  //Serial.print(temp); Serial.print("\r\n");      
  // another way to print; but, it prints "ovf" for large values!
  //Serial.print("fSENSOR1 = "); Serial.print(curr_fsensor1); 
  //Serial.print("    Delta1 = "); Serial.print(delta_fSENSOR1); 
  //Serial.print("    Percentage1 = "); Serial.print(percent_change_in_fSENSOR1); 
  //Serial.print("\r\n");

  // when metal target approaches, frequency increases;
  // 1000 value was determined empirically via observations;
  if ( (delta_fSENSOR1 > 2000) ) {
    //&& (percent_change_in_fSENSOR1 > THRESHOLD_PERCENTAGE_CHANGE_fSENSOR) ) { 
    target_detected_left = true;
    // signal target approached by turning Red the LED;
    digitalWrite(4, HIGH);
    Serial.print("-------- Metal target: LEFT! \r\n");
  } else {
    digitalWrite(4, LOW);
  }    

}
