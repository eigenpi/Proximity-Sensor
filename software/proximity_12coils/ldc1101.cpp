
// functions to interface with Texas Instruments' LDC1101.

#include "SPI2.h"
#include "ldc1101.h"

 
LDC1101::LDC1101(int ss_pin, float capacitor, float f_CLKIN, LDC_OPERATION_MODE oper_mode)
{
  
  // (1) initial settings;
  _ss_pin = ss_pin; // Arduino IDE pin 9
  _cap = capacitor; // 270pF
  _fCLKIN = f_CLKIN; // 10MHz generated by external clock-generator
  _operation_mode = oper_mode; // LDC_LHR_OPERATION is default
  _LHRoffset = 0;
  _f_sensor_min = 1; // MHz
  _Rcount = 0xffff; // 0xFFFF, max value
  
  // (2) start the Arduino modified SPI library;
  // i.e., launch the SPI2 object that connects the Atmega328p to the LDC chip;
  // note: in the case of Arduino Pro Mini, this would be PB1 or IDE Pin 9 (connected to MCU pin 13),
  // and would be passed to this ctor by the example that uses this LDC1101 class;
  _SPI2.begin();
  // Setup the spi for 8 bit data, high steady state clock,
  // second edge capture, with a 1MHz clock rate
  // Note: 
  // http://dlnware.com/theory/SPI-Transfer-Modes
  // https://www.arduino.cc/en/reference/SPI
  // https://www.arduino.cc/en/Tutorial/SPITransaction
  _SPI2.beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));

  // set the slave select pin as an Output:
  pinMode(_ss_pin, OUTPUT);
  digitalWrite(_ss_pin, LOW); 

  // (3) remaining initializations;
  init();
  
  digitalWrite(_ss_pin, HIGH); 
}

LDC1101::~LDC1101()
{
  // nothing;
}


void LDC1101::init()
{
  // SETTINGS 
  // C_sensor     = 270 pF
  // L_sensor     = 5 uH
  // Rp_min       = 1500 Ohm
  //
  // RCount       = 65535 (max)
  // Samplerate   = 15.3 Hz
  // t_conv       = 65.5 ms
  //
  // f_sensor_min = 1   MHz (d = inf)
  // f_sensor_max = 10  MHz (d = 0)
  // _two_to_divider = 2
  
  // (0) Set LDC1101 in configuration mode
  func_mode( LDC_MODE_SLEEP ); // b10 of reg START_CONFIG must be set to "01"


  // (1) things needed for RP+L mode:
  
  // - initialise RP+L mode & enable SHUTDOWN mode
  // setRPmode(); // RP+L mode
  // - set ResponseTime to 384 (default) or 6144 (slowest?), see page 18
  setResponseTime( LDC_RESPONSE_TIME_384 ); // i.e., 3
  // - set calibrated value for f_sensor_min (d = inf, no target)
  set_fsensor_min( _f_sensor_min ); // 1 MHz
  
  
  // (2) things needed for LHR mode:
  
  // - initialise LHR mode & enable SHUTDOWN mode
  setLHRmode(); // LHR mode
  // - set Reference Count to highest resolution
  setReferenceCount( _Rcount ); // 0xffff; max  
  // - set Divider to 1 
  setDivider( DIVIDER_3 ); 
  // - shift the signal down a bit
  setLHRoffset( _LHRoffset );
  
  if (_operation_mode == LDC_LHR_OPERATION) {
    // for LHR mode:
    // - disable RP_MAX
    // - set RP_MIN to 1.5KOhm (RPMAX_1_5KOhm)
    setRPsettings( 1, RPMAX_96KOhm, RPMIN_1_5KOhm ); // LHR mode, bool RP_MAX_DIS = 1
  } else { // LDC_RP_PLUS_L_OPERATION
    setRPsettings( 0, RPMAX_96KOhm, RPMIN_1_5KOhm ); // RP+L mode
  }


  // (3) Done configuring settings, set LDC1101 in measuring mode
  func_mode( LDC_MODE_ACTIVE_CONV ); // b10 of reg START_CONFIG must be set to "00"
}

void LDC1101::func_mode(LDC_FUNCTIONAL_MODE mode)
{ 
  writeSPI((uint8_t *)(&mode), 0x0B);
  //delay(1);
}


// () some set functions;

void LDC1101::setRPmode( void ){
  writeSPIregister( 0x05, 0x02 ); // ALT_CONFIG:  0000 0010 --> RP mode + Shutdown enabled
  writeSPIregister( 0x0C, 0x00 ); // D_CONFIG:    Enables LHR modus, disables RP 
}

void LDC1101::setLHRmode( void )
{
  writeSPIregister( 0x05, 0x03 ); // ALT_CONFIG:  0000 0011 --> LHR mode + Shutdown enabled
  writeSPIregister( 0x0C, 0x01 ); // D_CONFIG:    Enables LHR modus, disables RP 
}

void LDC1101::setRPsettings(bool RP_MAX_DIS, LDC_RP_MAX rpmax, LDC_RP_MIN rpmin)
{
  float rps[] = {96, 48, 24, 12, 6, 3, 1.5, 0.75};
  _RPmin = rps[rpmin];
  _RPmax = rps[rpmax];
  writeSPIregister(0x01, (RP_MAX_DIS << 7) | (rpmax << 4) | rpmin);
}

void LDC1101::setDivider(DIVIDER div)
{
  // for LHR mode use;
  // page 36 of Datasheet:
  // The reference clock frequency should be greater than 4 times the sensor frequency for 
  // optimum measurement resolution:
  // ƒCLKIN > 4 * ƒSENSOR_MAX
  // For higher sensor frequencies, this relationship may not be realizable without the 
  // sensor divider. Set the sensor divider to an appropriate value to produce an effective 
  // reduction in the sensor frequency:
  // ƒCLKIN > 4 * ƒSENSOR-MAX ÷ SENSOR_DIV
  // page 27 of Datasheet:
  // "SENSOR_DIV" is stored in Bits 1:0 of LHR_CONFIG Register
  // Divide the sensor frequency by programmed divider. This divider
  // can be used to set the sensor frequency lower than the reference frequency.
  uint8_t divs[] = {1, 2, 4, 8};
  _two_to_divider = divs[div];    
  writeSPIregister(0x34, div); 
} 

void LDC1101::setLHRoffset( uint32_t offset )
{
  // for LHR mode use;
  _LHRoffset = offset;
  uint16_t LHR_OFFSET = offset / 256; // dividing here by 2^8 so that in the calculation of fSENSOR I will not need to multiply by 2^8
  writeSPIregister(0x32, (uint8_t) (LHR_OFFSET & 0x00ff) );        //LSB
  writeSPIregister(0x33, (uint8_t) ((LHR_OFFSET & 0xff00) >> 8) ); //MSB
}

void LDC1101::setReferenceCount(uint16_t rcount)
{
  // for LHR mode use;
  _Rcount = rcount;
  uint8_t LHR_RCOUNT_LSB = (rcount & 0x00ff);
  uint8_t LHR_RCOUNT_MSB = ((rcount & 0xff00) >> 8);
  writeSPIregister(0x30, LHR_RCOUNT_LSB); //LSB
  writeSPIregister(0x31, LHR_RCOUNT_MSB); //MSB
}
void LDC1101::setSampleRate(float samplerate)
{ 
  // NOTE: not used
  // for LHR mode use;
  // see page 37 of Datasheet:
  // The conversion time represents the number of reference clock cycles used to measure the sensor frequency.
  // The LHR mode conversion time is set by the Reference count in LHR_RCOUNT.RCOUNT (registers 0x30 and 0x31).
  // The LHR conversion time is:
  // tCONV = (55 + RCOUNT * 16) / fCLKIN
  // that is why here:
  setReferenceCount( ((_fCLKIN/samplerate)-55)/16 ); 
}


void LDC1101::setResponseTime(LDC_RESPONSE_TIME responsetime) // "3"
{
  // for RP+L mode use;
  // "RESP_TIME" is the programmed response time in register 0x04.
  // It represents Bits 2:0 of Register DIG_CONF (page 18 of Datasheet):
  // This setting applies to the RP and Standard Resolution L
  // measurement, but not the High Resolution L measurement. 
  // RESP_TIME, Response Time, which is the number of sensor periods used per conversion.
  // Response Time = 384 (default value)
  uint16_t resps[] = {0, 0, 192, 384, 768, 1536, 3072, 6144}; // 384 picked up by "3"
  _responsetime = resps[responsetime]; // 384
  uint8_t DIG_CONF[1];    
  readSPI(DIG_CONF, 0x04, 1);
  writeSPIregister(0x04, ((DIG_CONF[0] & 0xF8) + responsetime)); // "3"
}
void LDC1101::set_fsensor_min(float f_sensor_min)
{
  // for RP+L mode use;
  // Address: 0x04, DIG_CONFIG (default value: 0x03), Configure RP+L conversion interval
  // Bits 7:4 of DIG_CONFIG represent "MIN_FREQ" - that is Sensor Minimum Frequency
  // From Datasheet, page 18, we see:
  // MIN_FREQ = 16 – (8 MHz ÷ ƒSENSORMIN)
  // 0000: ƒSENSORMIN = 500 kHz (default value)
  // 1111: ƒSENSORMIN = 8 MHz
  uint8_t DIG_CONF[1];    
  readSPI(DIG_CONF, 0x04, 1); // read DIG_CONF for its least significant 4 bits that we need to keep unchanged;
  uint8_t MIN_FREQ = 16.0f - (8.0f / f_sensor_min);
  writeSPIregister(0x04, ((MIN_FREQ << 4) + (DIG_CONF[0] & 0x0f)));
}


// () some get/query functions;


uint8_t LDC1101::get_LHR_status(void)
{
  // for use in LHR mode
  uint8_t LHR_status[1];
  readSPI( LHR_status, 0x3B, 1 );
  // see page 29 of Datasheet for individual bit values and their definitioan;
  // Bit index 0:
  // '0' : Unread LHR conversion data is available. This field is set to 0 at the
  //       end of an LHR conversion and remains asserted until a read of register 0x38
  // '1' : No unread LHR conversion data is available.
  //
  // LHR_DRDY: (LHR_status & 0x01) // Data ready
  return LHR_status[0];
}
bool LDC1101::is_New_LHR_data(void) 
{ 
  // return True if there is new LHR data, which has not been read yet; 
  return ( !(get_LHR_status() & 0x01) ); 
}


uint8_t LDC1101::get_status(void)
{
  // for use in RP+L mode
  // STATUS register is at address 0x20 (page 15 in Datasheet); it is 
  // RP+L measurement status register; see also page 24;
  uint8_t status[1];
  readSPI(status, 0x20, 1);   
  return status[0];
}
bool LDC1101::is_RP_L_DataReady(void) 
{ 
  // In Register STATUS, address = 0x20
  // Bit 6 is "DRDYB" RP+L Data Ready, with definition:
  // '0': New RP+L conversion data is available.
  // '1': No new conversion data is available.
  return ( !(get_status() & 0x40) ); 
}
bool LDC1101::is_Oscillation_Error(void) 
{ 
  // for use in RP+L mode
  // In Register STATUS, address = 0x20 
  // has Bit 7 as "NO_SENSOR_OSC", with description:
  // '0': Error condition has not occurred
  // '1': LDC1101 has not detected the sensor oscillation.
  return ( get_status() & 0x80 ); 
}


// () calculate stuff with sensor data


float LDC1101::get_fsensor( uint32_t Ldata )
{
  if (_operation_mode == LDC_LHR_OPERATION) { // default
    // ---> LHR mode
    if ( Ldata == 0 ) { Ldata = get_LHR_Data(); } 
    // according to page 36 in Datasheet:
    //_fsensor = (2^SENSOR_DIV) * _fCLKIN * (Ldata + _LHRoffset*2^8)/2^24; // in Hz  
    // but, I have:
    // 2^SENSOR_DIV    as: _two_to_divider 
    // LHROFFSET * 2^8 as: _LHRoffset
    // therefore:
    _fsensor = _two_to_divider * _fCLKIN * (Ldata + _LHRoffset)/16777216; 
  }
  else { // LDC_RP_PLUS_L_OPERATION
    // ---> RP+L mode
    if ( Ldata == 0 ) { Ldata = get_L_Data(); }
    // see page 33 of Dayasheet for this formula;
    _fsensor = (_fCLKIN * _responsetime) / (3 * Ldata); 
  }
  return _fsensor;
}  

float LDC1101::get_Inductance( uint32_t Ldata )
{  
  // in Henrys 
  float fsensor = get_fsensor( Ldata );
  _inductance = 1./(_cap * 4*PI*PI*fsensor*fsensor); // (page 36 in datasheet)
  return _inductance;
}

float LDC1101::get_fsensor_min()
{
  uint8_t DIG_CONF[1];
  readSPI(DIG_CONF, 0x04, 1);   
  return (float) 8.0f/(16.0f - (float) ((DIG_CONF[0] & 0xf0) >> 4));
} 

float LDC1101::get_Q(void) 
{ 
  return _RPmin * sqrt(_cap/_inductance*1000000); 
}  


// () functions to get data from the LDC1101 sensor;



uint32_t LDC1101::get_LHR_Data(void)
{
  uint32_t res;
  // High Resolution L Conversion Result Data:
  // LHR_DATA_MSB, LHR_DATA_MID, LHR_DATA_LSB
  // must be read from addresses 0x3A 0x39 0x38
  uint8_t LHR_DATA[3];
  readSPI(LHR_DATA, 0x38, 3); // 0x38 + 0x39 + 0x3A
  //return (LHR_DATA[2]<<16) | (LHR_DATA[1]<<8) | LHR_DATA[0];
  res = LHR_DATA[2];
  res = (res<<16) | (LHR_DATA[1]<<8) | LHR_DATA[0];
  return res;
}



uint16_t LDC1101::get_RP_Data(void)
{
  uint8_t RP_DATA[2];
  readSPI(RP_DATA, 0x21, 2); // 0x21 + 0x22
  return (RP_DATA[1]<<8) | RP_DATA[0];
}

float LDC1101::get_RP( uint16_t RPdata )
{
  // RP in Ohm's
  if ( RPdata == 0) {
    RPdata = get_RP_Data();
  }
  // see page 33 of Datasheet for this formula:
  return (_RPmax * _RPmin) / ( _RPmax * (1.0f - ((float) RPdata / 65535.0f)) + _RPmin * ((float) RPdata / 65535.0f));
}

uint16_t LDC1101::get_L_Data(void)
{
  uint8_t L_DATA[2];
  readSPI(L_DATA, 0x23, 2); // 0x23 + 0x24
  return (L_DATA[1]<<8) | L_DATA[0];
}



///////////////////////////////////////////////////////////////////////////////
//
// private functions
//
///////////////////////////////////////////////////////////////////////////////

void LDC1101::readSPI(uint8_t *data, uint8_t address, uint8_t num_bytes)
{
  // take the SS pin low to select the chip:
  digitalWrite( _ss_pin, LOW);
  //delay(100);  
  // send in the address and value via SPI:
  _SPI2.transfer(address | 0x80); // read flag 
  for ( int i=0; i < num_bytes; i++) {
    data[i] = _SPI2.transfer( 0xFF); // send a value of FF to read the first byte returned?
    //delay(100);
  }  
  // take the SS pin high to de-select the chip:
  digitalWrite( _ss_pin, HIGH);
}

void LDC1101::writeSPI(uint8_t *data, uint8_t address, uint8_t num_bytes)
{
  // take the SS pin low to select the chip:
  digitalWrite( _ss_pin, LOW);
  //delay(100);
  // send in the address and value via SPI:
  _SPI2.transfer(address);
  for ( int i=0; i < num_bytes; i++) {
    _SPI2.transfer( data[i]);
    //delay(100);
  }  
  // take the SS pin high to de-select the chip:
  digitalWrite( _ss_pin, HIGH);
}
